#!/bin/ruby

require 'date'

class Array
    def sum
        inject(nil) { |sum, x| sum ? sum+x : x }
    end

    def mean
        length == 0 ? 0 : inject(:+) / length 
    end

    def median
        len = length
        sorted = sort
        len % 2 == 1 ? sorted[len/2] : (sorted[len/2 -1] + sorted[len/2]) / 2
    end
end

class Fixnum
    def as_hours
        hours = (self / MIN_P_HR).to_i
        rem = self % MIN_P_HR
        return sprintf('%d:%02d', hours, rem)
    end
end

class Errors
    BAD_12_HR = 2
    BAD_FLAG = 4
    DELIM_OOO = 8
    END_ON_CLOCK_IN = 16
    NO_FILE = 32
    START_AFTER_STOP = 64
end

def accumulate(start, stop)
    if start > stop
        warn "start after stop at line #{$.}"
        $errs = $errs | Errors::START_AFTER_STOP
    end
    $work_p.push(((stop - start) * MIN_P_HR * HR_P_DAY ).to_i)
end

def parsetime(timestr)
    a = timestr.split($tdelim)
    
    t = Hash.new
    t["y"] = a[0].to_i
    t["m"] = a[1].to_i
    t["d"] = a[2].to_i
    t["h"] = a[3].to_i
    t["M"] = a[4].to_i

    #FIXME check the hash, or the array?
    
    if a.length == 6                               # AM or PM
        if a[5] !~ /^([Pp]|[Aa])[Mm]$/ 
            warn "Bad 12 hour format at #{$.}"
            $errs = $errs | Errors::BAD_12_HR
        end

        t["h"] = 0              if t["h"] == 12
        t["h"] = t["h"] + 12    if a[5]   == "PM"
    end

    return DateTime.new(t["y"], t["m"], t["d"], t["h"], t["M"] ) 
end

def summarize()
    if $verbose
        puts "as hours: #{$work_p.inject(:+).as_hours}"
        puts "as minutes: #{$work_p.inject(:+)}"
        puts "periods: #{$work_p.length}"
        puts "mean: #{$work_p.mean}"
        puts "median: #{$work_p.median}"
        puts "shortest: #{$work_p.min}"
        puts "longest: #{$work_p.max}"
    else
        puts $work_p.inject(:+)
    end

    if $very_verbose
        $work_p.each_with_index do |minutes, i|
            puts "p#{i+1}: #{minutes}"
        end
    end
end

MIN_P_HR = 60
HR_P_DAY = 24
CONFIG = ENV['HOME'] + "/.config/logtime/"

$tdelim = /[ :-]+/
$record_sep = /^[-\s]*$/
$speak = true
$errs = 0

loop { case ARGV[0]
    when '--status' then ARGV.shift; $speak = false
    when '-i' then ARGV.shift; $file = ARGV.shift
    when '-v' then ARGV.shift; $verbose = true
    when '-vv' then ARGV.shift; $very_verbose = true
    when '-r' then ARGV.shift; $record_sep = ARGV.shift
    when '--' then ARGV.shift; break
    when /^-/ 
        $errs = $errs | Errors::BAD_FLAG
        usage("Unknown option: #{ARGV[0].inspect}")
    else break
end; }

$clock = "out"
$work_p = Array.new
time = Hash.new

#fixme allow stdin
$file = CONFIG + ARGV.shift unless defined? $file

File.file?($file) or $errs = $errs | Errors::NO_FILE; exit $errs

File.open($file).each do |line|
    next if line =~ /^\s*#/
    line = line.chomp
    if line =~ $record_sep
        if $clock == "in"
            warn "Delimiter before end time at line #{$.}"
            $errs = $errs | Errors::DELIM_OOO
        end
        $clock = "out"
    else
        line.sub!(/#.*$/, "")
        $clock = $clock == "in" ? "out" : "in"
        time[$clock] = parsetime(line)

        if $clock == "out"
            accumulate(time["in"], time["out"])
        end
    end
end

if $speak
    if $clock == "in"
        warn "ended on clock in at line #{$.}"
        $errs = $errs | Errors::END_ON_CLOCK_IN
    end
    summarize()
else
    puts $clock
end

exit $errs
